// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tps.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tps_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tps_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "unreal_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tps_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tps_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tps_2eproto;
namespace tpspb {
class EntityChannelData;
struct EntityChannelDataDefaultTypeInternal;
extern EntityChannelDataDefaultTypeInternal _EntityChannelData_default_instance_;
class TestNPCState;
struct TestNPCStateDefaultTypeInternal;
extern TestNPCStateDefaultTypeInternal _TestNPCState_default_instance_;
class TestRepChannelData;
struct TestRepChannelDataDefaultTypeInternal;
extern TestRepChannelDataDefaultTypeInternal _TestRepChannelData_default_instance_;
class TestRepChannelData_ActorComponentStatesEntry_DoNotUse;
struct TestRepChannelData_ActorComponentStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_ActorComponentStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_ActorComponentStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_ActorStatesEntry_DoNotUse;
struct TestRepChannelData_ActorStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_ActorStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_ActorStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_CharacterStatesEntry_DoNotUse;
struct TestRepChannelData_CharacterStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_CharacterStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_CharacterStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_ControllerStatesEntry_DoNotUse;
struct TestRepChannelData_ControllerStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_ControllerStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_ControllerStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_PawnStatesEntry_DoNotUse;
struct TestRepChannelData_PawnStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_PawnStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_PawnStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_PlayerControllerStatesEntry_DoNotUse;
struct TestRepChannelData_PlayerControllerStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_PlayerControllerStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_PlayerControllerStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_PlayerStatesEntry_DoNotUse;
struct TestRepChannelData_PlayerStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_PlayerStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_PlayerStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_SceneComponentStatesEntry_DoNotUse;
struct TestRepChannelData_SceneComponentStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_SceneComponentStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_SceneComponentStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_TestNPCStatesEntry_DoNotUse;
struct TestRepChannelData_TestNPCStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_TestNPCStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_TestNPCStatesEntry_DoNotUse_default_instance_;
class TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse;
struct TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUseDefaultTypeInternal;
extern TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUseDefaultTypeInternal _TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse_default_instance_;
class TestRepGameState;
struct TestRepGameStateDefaultTypeInternal;
extern TestRepGameStateDefaultTypeInternal _TestRepGameState_default_instance_;
class TestRepGameState_MulticastNumber_Params;
struct TestRepGameState_MulticastNumber_ParamsDefaultTypeInternal;
extern TestRepGameState_MulticastNumber_ParamsDefaultTypeInternal _TestRepGameState_MulticastNumber_Params_default_instance_;
class TestRepPlayerControllerState;
struct TestRepPlayerControllerStateDefaultTypeInternal;
extern TestRepPlayerControllerStateDefaultTypeInternal _TestRepPlayerControllerState_default_instance_;
}  // namespace tpspb
PROTOBUF_NAMESPACE_OPEN
template<> ::tpspb::EntityChannelData* Arena::CreateMaybeMessage<::tpspb::EntityChannelData>(Arena*);
template<> ::tpspb::TestNPCState* Arena::CreateMaybeMessage<::tpspb::TestNPCState>(Arena*);
template<> ::tpspb::TestRepChannelData* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData>(Arena*);
template<> ::tpspb::TestRepChannelData_ActorComponentStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_ActorComponentStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_ActorStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_ActorStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_CharacterStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_CharacterStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_ControllerStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_ControllerStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_PawnStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_PawnStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_PlayerControllerStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_PlayerControllerStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_PlayerStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_PlayerStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_SceneComponentStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_SceneComponentStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_TestNPCStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_TestNPCStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::tpspb::TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse>(Arena*);
template<> ::tpspb::TestRepGameState* Arena::CreateMaybeMessage<::tpspb::TestRepGameState>(Arena*);
template<> ::tpspb::TestRepGameState_MulticastNumber_Params* Arena::CreateMaybeMessage<::tpspb::TestRepGameState_MulticastNumber_Params>(Arena*);
template<> ::tpspb::TestRepPlayerControllerState* Arena::CreateMaybeMessage<::tpspb::TestRepPlayerControllerState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tpspb {

// ===================================================================

class TestRepGameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.TestRepGameState) */ {
 public:
  inline TestRepGameState() : TestRepGameState(nullptr) {}
  ~TestRepGameState() override;
  explicit PROTOBUF_CONSTEXPR TestRepGameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRepGameState(const TestRepGameState& from);
  TestRepGameState(TestRepGameState&& from) noexcept
    : TestRepGameState() {
    *this = ::std::move(from);
  }

  inline TestRepGameState& operator=(const TestRepGameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRepGameState& operator=(TestRepGameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRepGameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRepGameState* internal_default_instance() {
    return reinterpret_cast<const TestRepGameState*>(
               &_TestRepGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TestRepGameState& a, TestRepGameState& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRepGameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRepGameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRepGameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRepGameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRepGameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRepGameState& from) {
    TestRepGameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRepGameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.TestRepGameState";
  }
  protected:
  explicit TestRepGameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJumpsFieldNumber = 1,
  };
  // optional int32 jumps = 1;
  bool has_jumps() const;
  private:
  bool _internal_has_jumps() const;
  public:
  void clear_jumps();
  int32_t jumps() const;
  void set_jumps(int32_t value);
  private:
  int32_t _internal_jumps() const;
  void _internal_set_jumps(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tpspb.TestRepGameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t jumps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// -------------------------------------------------------------------

class TestRepPlayerControllerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.TestRepPlayerControllerState) */ {
 public:
  inline TestRepPlayerControllerState() : TestRepPlayerControllerState(nullptr) {}
  ~TestRepPlayerControllerState() override;
  explicit PROTOBUF_CONSTEXPR TestRepPlayerControllerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRepPlayerControllerState(const TestRepPlayerControllerState& from);
  TestRepPlayerControllerState(TestRepPlayerControllerState&& from) noexcept
    : TestRepPlayerControllerState() {
    *this = ::std::move(from);
  }

  inline TestRepPlayerControllerState& operator=(const TestRepPlayerControllerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRepPlayerControllerState& operator=(TestRepPlayerControllerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRepPlayerControllerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRepPlayerControllerState* internal_default_instance() {
    return reinterpret_cast<const TestRepPlayerControllerState*>(
               &_TestRepPlayerControllerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TestRepPlayerControllerState& a, TestRepPlayerControllerState& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRepPlayerControllerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRepPlayerControllerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRepPlayerControllerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRepPlayerControllerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRepPlayerControllerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRepPlayerControllerState& from) {
    TestRepPlayerControllerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRepPlayerControllerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.TestRepPlayerControllerState";
  }
  protected:
  explicit TestRepPlayerControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestRepActorFieldNumber = 1,
  };
  // .unrealpb.UnrealObjectRef testRepActor = 1;
  bool has_testrepactor() const;
  private:
  bool _internal_has_testrepactor() const;
  public:
  void clear_testrepactor();
  const ::unrealpb::UnrealObjectRef& testrepactor() const;
  PROTOBUF_NODISCARD ::unrealpb::UnrealObjectRef* release_testrepactor();
  ::unrealpb::UnrealObjectRef* mutable_testrepactor();
  void set_allocated_testrepactor(::unrealpb::UnrealObjectRef* testrepactor);
  private:
  const ::unrealpb::UnrealObjectRef& _internal_testrepactor() const;
  ::unrealpb::UnrealObjectRef* _internal_mutable_testrepactor();
  public:
  void unsafe_arena_set_allocated_testrepactor(
      ::unrealpb::UnrealObjectRef* testrepactor);
  ::unrealpb::UnrealObjectRef* unsafe_arena_release_testrepactor();

  // @@protoc_insertion_point(class_scope:tpspb.TestRepPlayerControllerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unrealpb::UnrealObjectRef* testrepactor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// -------------------------------------------------------------------

class TestNPCState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.TestNPCState) */ {
 public:
  inline TestNPCState() : TestNPCState(nullptr) {}
  ~TestNPCState() override;
  explicit PROTOBUF_CONSTEXPR TestNPCState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestNPCState(const TestNPCState& from);
  TestNPCState(TestNPCState&& from) noexcept
    : TestNPCState() {
    *this = ::std::move(from);
  }

  inline TestNPCState& operator=(const TestNPCState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestNPCState& operator=(TestNPCState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestNPCState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestNPCState* internal_default_instance() {
    return reinterpret_cast<const TestNPCState*>(
               &_TestNPCState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TestNPCState& a, TestNPCState& b) {
    a.Swap(&b);
  }
  inline void Swap(TestNPCState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestNPCState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestNPCState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestNPCState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestNPCState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestNPCState& from) {
    TestNPCState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNPCState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.TestNPCState";
  }
  protected:
  explicit TestNPCState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoalLocationFieldNumber = 2,
    kBMovingFieldNumber = 1,
  };
  // optional .unrealpb.FVector goalLocation = 2;
  bool has_goallocation() const;
  private:
  bool _internal_has_goallocation() const;
  public:
  void clear_goallocation();
  const ::unrealpb::FVector& goallocation() const;
  PROTOBUF_NODISCARD ::unrealpb::FVector* release_goallocation();
  ::unrealpb::FVector* mutable_goallocation();
  void set_allocated_goallocation(::unrealpb::FVector* goallocation);
  private:
  const ::unrealpb::FVector& _internal_goallocation() const;
  ::unrealpb::FVector* _internal_mutable_goallocation();
  public:
  void unsafe_arena_set_allocated_goallocation(
      ::unrealpb::FVector* goallocation);
  ::unrealpb::FVector* unsafe_arena_release_goallocation();

  // optional bool bMoving = 1;
  bool has_bmoving() const;
  private:
  bool _internal_has_bmoving() const;
  public:
  void clear_bmoving();
  bool bmoving() const;
  void set_bmoving(bool value);
  private:
  bool _internal_bmoving() const;
  void _internal_set_bmoving(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tpspb.TestNPCState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::unrealpb::FVector* goallocation_;
    bool bmoving_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// -------------------------------------------------------------------

class EntityChannelData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.EntityChannelData) */ {
 public:
  inline EntityChannelData() : EntityChannelData(nullptr) {}
  ~EntityChannelData() override;
  explicit PROTOBUF_CONSTEXPR EntityChannelData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityChannelData(const EntityChannelData& from);
  EntityChannelData(EntityChannelData&& from) noexcept
    : EntityChannelData() {
    *this = ::std::move(from);
  }

  inline EntityChannelData& operator=(const EntityChannelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityChannelData& operator=(EntityChannelData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityChannelData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityChannelData* internal_default_instance() {
    return reinterpret_cast<const EntityChannelData*>(
               &_EntityChannelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EntityChannelData& a, EntityChannelData& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityChannelData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityChannelData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityChannelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityChannelData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityChannelData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntityChannelData& from) {
    EntityChannelData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityChannelData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.EntityChannelData";
  }
  protected:
  explicit EntityChannelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjRefFieldNumber = 1,
    kActorStateFieldNumber = 2,
    kPawnStateFieldNumber = 3,
    kCharacterStateFieldNumber = 4,
    kPlayerStateFieldNumber = 5,
    kControllerStateFieldNumber = 6,
    kPlayerControllerStateFieldNumber = 7,
    kActorComponentStateFieldNumber = 8,
    kSceneComponentStateFieldNumber = 9,
    kTestRepPlayerControllerStateFieldNumber = 11,
    kTestNPCStateFieldNumber = 12,
  };
  // .unrealpb.UnrealObjectRef objRef = 1;
  bool has_objref() const;
  private:
  bool _internal_has_objref() const;
  public:
  void clear_objref();
  const ::unrealpb::UnrealObjectRef& objref() const;
  PROTOBUF_NODISCARD ::unrealpb::UnrealObjectRef* release_objref();
  ::unrealpb::UnrealObjectRef* mutable_objref();
  void set_allocated_objref(::unrealpb::UnrealObjectRef* objref);
  private:
  const ::unrealpb::UnrealObjectRef& _internal_objref() const;
  ::unrealpb::UnrealObjectRef* _internal_mutable_objref();
  public:
  void unsafe_arena_set_allocated_objref(
      ::unrealpb::UnrealObjectRef* objref);
  ::unrealpb::UnrealObjectRef* unsafe_arena_release_objref();

  // optional .unrealpb.ActorState actorState = 2;
  bool has_actorstate() const;
  private:
  bool _internal_has_actorstate() const;
  public:
  void clear_actorstate();
  const ::unrealpb::ActorState& actorstate() const;
  PROTOBUF_NODISCARD ::unrealpb::ActorState* release_actorstate();
  ::unrealpb::ActorState* mutable_actorstate();
  void set_allocated_actorstate(::unrealpb::ActorState* actorstate);
  private:
  const ::unrealpb::ActorState& _internal_actorstate() const;
  ::unrealpb::ActorState* _internal_mutable_actorstate();
  public:
  void unsafe_arena_set_allocated_actorstate(
      ::unrealpb::ActorState* actorstate);
  ::unrealpb::ActorState* unsafe_arena_release_actorstate();

  // optional .unrealpb.PawnState pawnState = 3;
  bool has_pawnstate() const;
  private:
  bool _internal_has_pawnstate() const;
  public:
  void clear_pawnstate();
  const ::unrealpb::PawnState& pawnstate() const;
  PROTOBUF_NODISCARD ::unrealpb::PawnState* release_pawnstate();
  ::unrealpb::PawnState* mutable_pawnstate();
  void set_allocated_pawnstate(::unrealpb::PawnState* pawnstate);
  private:
  const ::unrealpb::PawnState& _internal_pawnstate() const;
  ::unrealpb::PawnState* _internal_mutable_pawnstate();
  public:
  void unsafe_arena_set_allocated_pawnstate(
      ::unrealpb::PawnState* pawnstate);
  ::unrealpb::PawnState* unsafe_arena_release_pawnstate();

  // optional .unrealpb.CharacterState characterState = 4;
  bool has_characterstate() const;
  private:
  bool _internal_has_characterstate() const;
  public:
  void clear_characterstate();
  const ::unrealpb::CharacterState& characterstate() const;
  PROTOBUF_NODISCARD ::unrealpb::CharacterState* release_characterstate();
  ::unrealpb::CharacterState* mutable_characterstate();
  void set_allocated_characterstate(::unrealpb::CharacterState* characterstate);
  private:
  const ::unrealpb::CharacterState& _internal_characterstate() const;
  ::unrealpb::CharacterState* _internal_mutable_characterstate();
  public:
  void unsafe_arena_set_allocated_characterstate(
      ::unrealpb::CharacterState* characterstate);
  ::unrealpb::CharacterState* unsafe_arena_release_characterstate();

  // optional .unrealpb.PlayerState playerState = 5;
  bool has_playerstate() const;
  private:
  bool _internal_has_playerstate() const;
  public:
  void clear_playerstate();
  const ::unrealpb::PlayerState& playerstate() const;
  PROTOBUF_NODISCARD ::unrealpb::PlayerState* release_playerstate();
  ::unrealpb::PlayerState* mutable_playerstate();
  void set_allocated_playerstate(::unrealpb::PlayerState* playerstate);
  private:
  const ::unrealpb::PlayerState& _internal_playerstate() const;
  ::unrealpb::PlayerState* _internal_mutable_playerstate();
  public:
  void unsafe_arena_set_allocated_playerstate(
      ::unrealpb::PlayerState* playerstate);
  ::unrealpb::PlayerState* unsafe_arena_release_playerstate();

  // optional .unrealpb.ControllerState controllerState = 6;
  bool has_controllerstate() const;
  private:
  bool _internal_has_controllerstate() const;
  public:
  void clear_controllerstate();
  const ::unrealpb::ControllerState& controllerstate() const;
  PROTOBUF_NODISCARD ::unrealpb::ControllerState* release_controllerstate();
  ::unrealpb::ControllerState* mutable_controllerstate();
  void set_allocated_controllerstate(::unrealpb::ControllerState* controllerstate);
  private:
  const ::unrealpb::ControllerState& _internal_controllerstate() const;
  ::unrealpb::ControllerState* _internal_mutable_controllerstate();
  public:
  void unsafe_arena_set_allocated_controllerstate(
      ::unrealpb::ControllerState* controllerstate);
  ::unrealpb::ControllerState* unsafe_arena_release_controllerstate();

  // optional .unrealpb.PlayerControllerState playerControllerState = 7;
  bool has_playercontrollerstate() const;
  private:
  bool _internal_has_playercontrollerstate() const;
  public:
  void clear_playercontrollerstate();
  const ::unrealpb::PlayerControllerState& playercontrollerstate() const;
  PROTOBUF_NODISCARD ::unrealpb::PlayerControllerState* release_playercontrollerstate();
  ::unrealpb::PlayerControllerState* mutable_playercontrollerstate();
  void set_allocated_playercontrollerstate(::unrealpb::PlayerControllerState* playercontrollerstate);
  private:
  const ::unrealpb::PlayerControllerState& _internal_playercontrollerstate() const;
  ::unrealpb::PlayerControllerState* _internal_mutable_playercontrollerstate();
  public:
  void unsafe_arena_set_allocated_playercontrollerstate(
      ::unrealpb::PlayerControllerState* playercontrollerstate);
  ::unrealpb::PlayerControllerState* unsafe_arena_release_playercontrollerstate();

  // optional .unrealpb.ActorComponentState actorComponentState = 8;
  bool has_actorcomponentstate() const;
  private:
  bool _internal_has_actorcomponentstate() const;
  public:
  void clear_actorcomponentstate();
  const ::unrealpb::ActorComponentState& actorcomponentstate() const;
  PROTOBUF_NODISCARD ::unrealpb::ActorComponentState* release_actorcomponentstate();
  ::unrealpb::ActorComponentState* mutable_actorcomponentstate();
  void set_allocated_actorcomponentstate(::unrealpb::ActorComponentState* actorcomponentstate);
  private:
  const ::unrealpb::ActorComponentState& _internal_actorcomponentstate() const;
  ::unrealpb::ActorComponentState* _internal_mutable_actorcomponentstate();
  public:
  void unsafe_arena_set_allocated_actorcomponentstate(
      ::unrealpb::ActorComponentState* actorcomponentstate);
  ::unrealpb::ActorComponentState* unsafe_arena_release_actorcomponentstate();

  // optional .unrealpb.SceneComponentState sceneComponentState = 9;
  bool has_scenecomponentstate() const;
  private:
  bool _internal_has_scenecomponentstate() const;
  public:
  void clear_scenecomponentstate();
  const ::unrealpb::SceneComponentState& scenecomponentstate() const;
  PROTOBUF_NODISCARD ::unrealpb::SceneComponentState* release_scenecomponentstate();
  ::unrealpb::SceneComponentState* mutable_scenecomponentstate();
  void set_allocated_scenecomponentstate(::unrealpb::SceneComponentState* scenecomponentstate);
  private:
  const ::unrealpb::SceneComponentState& _internal_scenecomponentstate() const;
  ::unrealpb::SceneComponentState* _internal_mutable_scenecomponentstate();
  public:
  void unsafe_arena_set_allocated_scenecomponentstate(
      ::unrealpb::SceneComponentState* scenecomponentstate);
  ::unrealpb::SceneComponentState* unsafe_arena_release_scenecomponentstate();

  // optional .tpspb.TestRepPlayerControllerState testRepPlayerControllerState = 11;
  bool has_testrepplayercontrollerstate() const;
  private:
  bool _internal_has_testrepplayercontrollerstate() const;
  public:
  void clear_testrepplayercontrollerstate();
  const ::tpspb::TestRepPlayerControllerState& testrepplayercontrollerstate() const;
  PROTOBUF_NODISCARD ::tpspb::TestRepPlayerControllerState* release_testrepplayercontrollerstate();
  ::tpspb::TestRepPlayerControllerState* mutable_testrepplayercontrollerstate();
  void set_allocated_testrepplayercontrollerstate(::tpspb::TestRepPlayerControllerState* testrepplayercontrollerstate);
  private:
  const ::tpspb::TestRepPlayerControllerState& _internal_testrepplayercontrollerstate() const;
  ::tpspb::TestRepPlayerControllerState* _internal_mutable_testrepplayercontrollerstate();
  public:
  void unsafe_arena_set_allocated_testrepplayercontrollerstate(
      ::tpspb::TestRepPlayerControllerState* testrepplayercontrollerstate);
  ::tpspb::TestRepPlayerControllerState* unsafe_arena_release_testrepplayercontrollerstate();

  // optional .tpspb.TestNPCState testNPCState = 12;
  bool has_testnpcstate() const;
  private:
  bool _internal_has_testnpcstate() const;
  public:
  void clear_testnpcstate();
  const ::tpspb::TestNPCState& testnpcstate() const;
  PROTOBUF_NODISCARD ::tpspb::TestNPCState* release_testnpcstate();
  ::tpspb::TestNPCState* mutable_testnpcstate();
  void set_allocated_testnpcstate(::tpspb::TestNPCState* testnpcstate);
  private:
  const ::tpspb::TestNPCState& _internal_testnpcstate() const;
  ::tpspb::TestNPCState* _internal_mutable_testnpcstate();
  public:
  void unsafe_arena_set_allocated_testnpcstate(
      ::tpspb::TestNPCState* testnpcstate);
  ::tpspb::TestNPCState* unsafe_arena_release_testnpcstate();

  // @@protoc_insertion_point(class_scope:tpspb.EntityChannelData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::unrealpb::UnrealObjectRef* objref_;
    ::unrealpb::ActorState* actorstate_;
    ::unrealpb::PawnState* pawnstate_;
    ::unrealpb::CharacterState* characterstate_;
    ::unrealpb::PlayerState* playerstate_;
    ::unrealpb::ControllerState* controllerstate_;
    ::unrealpb::PlayerControllerState* playercontrollerstate_;
    ::unrealpb::ActorComponentState* actorcomponentstate_;
    ::unrealpb::SceneComponentState* scenecomponentstate_;
    ::tpspb::TestRepPlayerControllerState* testrepplayercontrollerstate_;
    ::tpspb::TestNPCState* testnpcstate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// -------------------------------------------------------------------

class TestRepChannelData_ActorStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ActorStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ActorState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ActorStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ActorState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_ActorStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_ActorStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_ActorStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_ActorStatesEntry_DoNotUse& other);
  static const TestRepChannelData_ActorStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_ActorStatesEntry_DoNotUse*>(&_TestRepChannelData_ActorStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_PawnStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PawnStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PawnState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PawnStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PawnState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_PawnStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_PawnStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_PawnStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_PawnStatesEntry_DoNotUse& other);
  static const TestRepChannelData_PawnStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_PawnStatesEntry_DoNotUse*>(&_TestRepChannelData_PawnStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_CharacterStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_CharacterStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::CharacterState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_CharacterStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::CharacterState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_CharacterStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_CharacterStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_CharacterStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_CharacterStatesEntry_DoNotUse& other);
  static const TestRepChannelData_CharacterStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_CharacterStatesEntry_DoNotUse*>(&_TestRepChannelData_CharacterStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_PlayerStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PlayerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PlayerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PlayerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PlayerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_PlayerStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_PlayerStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_PlayerStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_PlayerStatesEntry_DoNotUse& other);
  static const TestRepChannelData_PlayerStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_PlayerStatesEntry_DoNotUse*>(&_TestRepChannelData_PlayerStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_ControllerStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ControllerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ControllerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_ControllerStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_ControllerStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_ControllerStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_ControllerStatesEntry_DoNotUse& other);
  static const TestRepChannelData_ControllerStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_ControllerStatesEntry_DoNotUse*>(&_TestRepChannelData_ControllerStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_PlayerControllerStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PlayerControllerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PlayerControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_PlayerControllerStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::PlayerControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_PlayerControllerStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_PlayerControllerStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_PlayerControllerStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_PlayerControllerStatesEntry_DoNotUse& other);
  static const TestRepChannelData_PlayerControllerStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_PlayerControllerStatesEntry_DoNotUse*>(&_TestRepChannelData_PlayerControllerStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_ActorComponentStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ActorComponentStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ActorComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_ActorComponentStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::ActorComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_ActorComponentStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_ActorComponentStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_ActorComponentStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_ActorComponentStatesEntry_DoNotUse& other);
  static const TestRepChannelData_ActorComponentStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_ActorComponentStatesEntry_DoNotUse*>(&_TestRepChannelData_ActorComponentStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_SceneComponentStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_SceneComponentStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::SceneComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_SceneComponentStatesEntry_DoNotUse, 
    uint32_t, ::unrealpb::SceneComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_SceneComponentStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_SceneComponentStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_SceneComponentStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_SceneComponentStatesEntry_DoNotUse& other);
  static const TestRepChannelData_SceneComponentStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_SceneComponentStatesEntry_DoNotUse*>(&_TestRepChannelData_SceneComponentStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse, 
    uint32_t, ::tpspb::TestRepPlayerControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse, 
    uint32_t, ::tpspb::TestRepPlayerControllerState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse& other);
  static const TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse*>(&_TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData_TestNPCStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_TestNPCStatesEntry_DoNotUse, 
    uint32_t, ::tpspb::TestNPCState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRepChannelData_TestNPCStatesEntry_DoNotUse, 
    uint32_t, ::tpspb::TestNPCState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestRepChannelData_TestNPCStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TestRepChannelData_TestNPCStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRepChannelData_TestNPCStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRepChannelData_TestNPCStatesEntry_DoNotUse& other);
  static const TestRepChannelData_TestNPCStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRepChannelData_TestNPCStatesEntry_DoNotUse*>(&_TestRepChannelData_TestNPCStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tps_2eproto;
};

// -------------------------------------------------------------------

class TestRepChannelData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.TestRepChannelData) */ {
 public:
  inline TestRepChannelData() : TestRepChannelData(nullptr) {}
  ~TestRepChannelData() override;
  explicit PROTOBUF_CONSTEXPR TestRepChannelData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRepChannelData(const TestRepChannelData& from);
  TestRepChannelData(TestRepChannelData&& from) noexcept
    : TestRepChannelData() {
    *this = ::std::move(from);
  }

  inline TestRepChannelData& operator=(const TestRepChannelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRepChannelData& operator=(TestRepChannelData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRepChannelData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRepChannelData* internal_default_instance() {
    return reinterpret_cast<const TestRepChannelData*>(
               &_TestRepChannelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TestRepChannelData& a, TestRepChannelData& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRepChannelData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRepChannelData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRepChannelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRepChannelData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRepChannelData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRepChannelData& from) {
    TestRepChannelData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRepChannelData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.TestRepChannelData";
  }
  protected:
  explicit TestRepChannelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kActorStatesFieldNumber = 2,
    kPawnStatesFieldNumber = 3,
    kCharacterStatesFieldNumber = 4,
    kPlayerStatesFieldNumber = 5,
    kControllerStatesFieldNumber = 6,
    kPlayerControllerStatesFieldNumber = 7,
    kActorComponentStatesFieldNumber = 8,
    kSceneComponentStatesFieldNumber = 9,
    kTestRepPlayerControllerStatesFieldNumber = 11,
    kTestNPCStatesFieldNumber = 12,
    kGameStateFieldNumber = 1,
    kTestGameStateFieldNumber = 10,
  };
  // map<uint32, .unrealpb.ActorState> actorStates = 2;
  int actorstates_size() const;
  private:
  int _internal_actorstates_size() const;
  public:
  void clear_actorstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >&
      _internal_actorstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >*
      _internal_mutable_actorstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >&
      actorstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >*
      mutable_actorstates();

  // map<uint32, .unrealpb.PawnState> pawnStates = 3;
  int pawnstates_size() const;
  private:
  int _internal_pawnstates_size() const;
  public:
  void clear_pawnstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >&
      _internal_pawnstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >*
      _internal_mutable_pawnstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >&
      pawnstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >*
      mutable_pawnstates();

  // map<uint32, .unrealpb.CharacterState> characterStates = 4;
  int characterstates_size() const;
  private:
  int _internal_characterstates_size() const;
  public:
  void clear_characterstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >&
      _internal_characterstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >*
      _internal_mutable_characterstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >&
      characterstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >*
      mutable_characterstates();

  // map<uint32, .unrealpb.PlayerState> playerStates = 5;
  int playerstates_size() const;
  private:
  int _internal_playerstates_size() const;
  public:
  void clear_playerstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >&
      _internal_playerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >*
      _internal_mutable_playerstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >&
      playerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >*
      mutable_playerstates();

  // map<uint32, .unrealpb.ControllerState> controllerStates = 6;
  int controllerstates_size() const;
  private:
  int _internal_controllerstates_size() const;
  public:
  void clear_controllerstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >&
      _internal_controllerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >*
      _internal_mutable_controllerstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >&
      controllerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >*
      mutable_controllerstates();

  // map<uint32, .unrealpb.PlayerControllerState> playerControllerStates = 7;
  int playercontrollerstates_size() const;
  private:
  int _internal_playercontrollerstates_size() const;
  public:
  void clear_playercontrollerstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >&
      _internal_playercontrollerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >*
      _internal_mutable_playercontrollerstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >&
      playercontrollerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >*
      mutable_playercontrollerstates();

  // map<uint32, .unrealpb.ActorComponentState> actorComponentStates = 8;
  int actorcomponentstates_size() const;
  private:
  int _internal_actorcomponentstates_size() const;
  public:
  void clear_actorcomponentstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >&
      _internal_actorcomponentstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >*
      _internal_mutable_actorcomponentstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >&
      actorcomponentstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >*
      mutable_actorcomponentstates();

  // map<uint32, .unrealpb.SceneComponentState> sceneComponentStates = 9;
  int scenecomponentstates_size() const;
  private:
  int _internal_scenecomponentstates_size() const;
  public:
  void clear_scenecomponentstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >&
      _internal_scenecomponentstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >*
      _internal_mutable_scenecomponentstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >&
      scenecomponentstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >*
      mutable_scenecomponentstates();

  // map<uint32, .tpspb.TestRepPlayerControllerState> testRepPlayerControllerStates = 11;
  int testrepplayercontrollerstates_size() const;
  private:
  int _internal_testrepplayercontrollerstates_size() const;
  public:
  void clear_testrepplayercontrollerstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >&
      _internal_testrepplayercontrollerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >*
      _internal_mutable_testrepplayercontrollerstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >&
      testrepplayercontrollerstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >*
      mutable_testrepplayercontrollerstates();

  // map<uint32, .tpspb.TestNPCState> testNPCStates = 12;
  int testnpcstates_size() const;
  private:
  int _internal_testnpcstates_size() const;
  public:
  void clear_testnpcstates();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >&
      _internal_testnpcstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >*
      _internal_mutable_testnpcstates();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >&
      testnpcstates() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >*
      mutable_testnpcstates();

  // .unrealpb.GameStateBase gameState = 1;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  const ::unrealpb::GameStateBase& gamestate() const;
  PROTOBUF_NODISCARD ::unrealpb::GameStateBase* release_gamestate();
  ::unrealpb::GameStateBase* mutable_gamestate();
  void set_allocated_gamestate(::unrealpb::GameStateBase* gamestate);
  private:
  const ::unrealpb::GameStateBase& _internal_gamestate() const;
  ::unrealpb::GameStateBase* _internal_mutable_gamestate();
  public:
  void unsafe_arena_set_allocated_gamestate(
      ::unrealpb::GameStateBase* gamestate);
  ::unrealpb::GameStateBase* unsafe_arena_release_gamestate();

  // .tpspb.TestRepGameState testGameState = 10;
  bool has_testgamestate() const;
  private:
  bool _internal_has_testgamestate() const;
  public:
  void clear_testgamestate();
  const ::tpspb::TestRepGameState& testgamestate() const;
  PROTOBUF_NODISCARD ::tpspb::TestRepGameState* release_testgamestate();
  ::tpspb::TestRepGameState* mutable_testgamestate();
  void set_allocated_testgamestate(::tpspb::TestRepGameState* testgamestate);
  private:
  const ::tpspb::TestRepGameState& _internal_testgamestate() const;
  ::tpspb::TestRepGameState* _internal_mutable_testgamestate();
  public:
  void unsafe_arena_set_allocated_testgamestate(
      ::tpspb::TestRepGameState* testgamestate);
  ::tpspb::TestRepGameState* unsafe_arena_release_testgamestate();

  // @@protoc_insertion_point(class_scope:tpspb.TestRepChannelData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_ActorStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::ActorState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> actorstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_PawnStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::PawnState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> pawnstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_CharacterStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::CharacterState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> characterstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_PlayerStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::PlayerState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> playerstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_ControllerStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::ControllerState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> controllerstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_PlayerControllerStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::PlayerControllerState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> playercontrollerstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_ActorComponentStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::ActorComponentState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> actorcomponentstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_SceneComponentStatesEntry_DoNotUse,
        uint32_t, ::unrealpb::SceneComponentState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> scenecomponentstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_TestRepPlayerControllerStatesEntry_DoNotUse,
        uint32_t, ::tpspb::TestRepPlayerControllerState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> testrepplayercontrollerstates_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRepChannelData_TestNPCStatesEntry_DoNotUse,
        uint32_t, ::tpspb::TestNPCState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> testnpcstates_;
    ::unrealpb::GameStateBase* gamestate_;
    ::tpspb::TestRepGameState* testgamestate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// -------------------------------------------------------------------

class TestRepGameState_MulticastNumber_Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpspb.TestRepGameState_MulticastNumber_Params) */ {
 public:
  inline TestRepGameState_MulticastNumber_Params() : TestRepGameState_MulticastNumber_Params(nullptr) {}
  ~TestRepGameState_MulticastNumber_Params() override;
  explicit PROTOBUF_CONSTEXPR TestRepGameState_MulticastNumber_Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRepGameState_MulticastNumber_Params(const TestRepGameState_MulticastNumber_Params& from);
  TestRepGameState_MulticastNumber_Params(TestRepGameState_MulticastNumber_Params&& from) noexcept
    : TestRepGameState_MulticastNumber_Params() {
    *this = ::std::move(from);
  }

  inline TestRepGameState_MulticastNumber_Params& operator=(const TestRepGameState_MulticastNumber_Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRepGameState_MulticastNumber_Params& operator=(TestRepGameState_MulticastNumber_Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRepGameState_MulticastNumber_Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRepGameState_MulticastNumber_Params* internal_default_instance() {
    return reinterpret_cast<const TestRepGameState_MulticastNumber_Params*>(
               &_TestRepGameState_MulticastNumber_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TestRepGameState_MulticastNumber_Params& a, TestRepGameState_MulticastNumber_Params& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRepGameState_MulticastNumber_Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRepGameState_MulticastNumber_Params* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRepGameState_MulticastNumber_Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRepGameState_MulticastNumber_Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRepGameState_MulticastNumber_Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRepGameState_MulticastNumber_Params& from) {
    TestRepGameState_MulticastNumber_Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRepGameState_MulticastNumber_Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpspb.TestRepGameState_MulticastNumber_Params";
  }
  protected:
  explicit TestRepGameState_MulticastNumber_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 1,
  };
  // optional int32 num = 1;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tpspb.TestRepGameState_MulticastNumber_Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t num_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tps_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TestRepGameState

// optional int32 jumps = 1;
inline bool TestRepGameState::_internal_has_jumps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestRepGameState::has_jumps() const {
  return _internal_has_jumps();
}
inline void TestRepGameState::clear_jumps() {
  _impl_.jumps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestRepGameState::_internal_jumps() const {
  return _impl_.jumps_;
}
inline int32_t TestRepGameState::jumps() const {
  // @@protoc_insertion_point(field_get:tpspb.TestRepGameState.jumps)
  return _internal_jumps();
}
inline void TestRepGameState::_internal_set_jumps(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.jumps_ = value;
}
inline void TestRepGameState::set_jumps(int32_t value) {
  _internal_set_jumps(value);
  // @@protoc_insertion_point(field_set:tpspb.TestRepGameState.jumps)
}

// -------------------------------------------------------------------

// TestRepPlayerControllerState

// .unrealpb.UnrealObjectRef testRepActor = 1;
inline bool TestRepPlayerControllerState::_internal_has_testrepactor() const {
  return this != internal_default_instance() && _impl_.testrepactor_ != nullptr;
}
inline bool TestRepPlayerControllerState::has_testrepactor() const {
  return _internal_has_testrepactor();
}
inline const ::unrealpb::UnrealObjectRef& TestRepPlayerControllerState::_internal_testrepactor() const {
  const ::unrealpb::UnrealObjectRef* p = _impl_.testrepactor_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::UnrealObjectRef&>(
      ::unrealpb::_UnrealObjectRef_default_instance_);
}
inline const ::unrealpb::UnrealObjectRef& TestRepPlayerControllerState::testrepactor() const {
  // @@protoc_insertion_point(field_get:tpspb.TestRepPlayerControllerState.testRepActor)
  return _internal_testrepactor();
}
inline void TestRepPlayerControllerState::unsafe_arena_set_allocated_testrepactor(
    ::unrealpb::UnrealObjectRef* testrepactor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testrepactor_);
  }
  _impl_.testrepactor_ = testrepactor;
  if (testrepactor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.TestRepPlayerControllerState.testRepActor)
}
inline ::unrealpb::UnrealObjectRef* TestRepPlayerControllerState::release_testrepactor() {
  
  ::unrealpb::UnrealObjectRef* temp = _impl_.testrepactor_;
  _impl_.testrepactor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::UnrealObjectRef* TestRepPlayerControllerState::unsafe_arena_release_testrepactor() {
  // @@protoc_insertion_point(field_release:tpspb.TestRepPlayerControllerState.testRepActor)
  
  ::unrealpb::UnrealObjectRef* temp = _impl_.testrepactor_;
  _impl_.testrepactor_ = nullptr;
  return temp;
}
inline ::unrealpb::UnrealObjectRef* TestRepPlayerControllerState::_internal_mutable_testrepactor() {
  
  if (_impl_.testrepactor_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::UnrealObjectRef>(GetArenaForAllocation());
    _impl_.testrepactor_ = p;
  }
  return _impl_.testrepactor_;
}
inline ::unrealpb::UnrealObjectRef* TestRepPlayerControllerState::mutable_testrepactor() {
  ::unrealpb::UnrealObjectRef* _msg = _internal_mutable_testrepactor();
  // @@protoc_insertion_point(field_mutable:tpspb.TestRepPlayerControllerState.testRepActor)
  return _msg;
}
inline void TestRepPlayerControllerState::set_allocated_testrepactor(::unrealpb::UnrealObjectRef* testrepactor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testrepactor_);
  }
  if (testrepactor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(testrepactor));
    if (message_arena != submessage_arena) {
      testrepactor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testrepactor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.testrepactor_ = testrepactor;
  // @@protoc_insertion_point(field_set_allocated:tpspb.TestRepPlayerControllerState.testRepActor)
}

// -------------------------------------------------------------------

// TestNPCState

// optional bool bMoving = 1;
inline bool TestNPCState::_internal_has_bmoving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestNPCState::has_bmoving() const {
  return _internal_has_bmoving();
}
inline void TestNPCState::clear_bmoving() {
  _impl_.bmoving_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TestNPCState::_internal_bmoving() const {
  return _impl_.bmoving_;
}
inline bool TestNPCState::bmoving() const {
  // @@protoc_insertion_point(field_get:tpspb.TestNPCState.bMoving)
  return _internal_bmoving();
}
inline void TestNPCState::_internal_set_bmoving(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bmoving_ = value;
}
inline void TestNPCState::set_bmoving(bool value) {
  _internal_set_bmoving(value);
  // @@protoc_insertion_point(field_set:tpspb.TestNPCState.bMoving)
}

// optional .unrealpb.FVector goalLocation = 2;
inline bool TestNPCState::_internal_has_goallocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goallocation_ != nullptr);
  return value;
}
inline bool TestNPCState::has_goallocation() const {
  return _internal_has_goallocation();
}
inline const ::unrealpb::FVector& TestNPCState::_internal_goallocation() const {
  const ::unrealpb::FVector* p = _impl_.goallocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::FVector&>(
      ::unrealpb::_FVector_default_instance_);
}
inline const ::unrealpb::FVector& TestNPCState::goallocation() const {
  // @@protoc_insertion_point(field_get:tpspb.TestNPCState.goalLocation)
  return _internal_goallocation();
}
inline void TestNPCState::unsafe_arena_set_allocated_goallocation(
    ::unrealpb::FVector* goallocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goallocation_);
  }
  _impl_.goallocation_ = goallocation;
  if (goallocation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.TestNPCState.goalLocation)
}
inline ::unrealpb::FVector* TestNPCState::release_goallocation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::unrealpb::FVector* temp = _impl_.goallocation_;
  _impl_.goallocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::FVector* TestNPCState::unsafe_arena_release_goallocation() {
  // @@protoc_insertion_point(field_release:tpspb.TestNPCState.goalLocation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::unrealpb::FVector* temp = _impl_.goallocation_;
  _impl_.goallocation_ = nullptr;
  return temp;
}
inline ::unrealpb::FVector* TestNPCState::_internal_mutable_goallocation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.goallocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::FVector>(GetArenaForAllocation());
    _impl_.goallocation_ = p;
  }
  return _impl_.goallocation_;
}
inline ::unrealpb::FVector* TestNPCState::mutable_goallocation() {
  ::unrealpb::FVector* _msg = _internal_mutable_goallocation();
  // @@protoc_insertion_point(field_mutable:tpspb.TestNPCState.goalLocation)
  return _msg;
}
inline void TestNPCState::set_allocated_goallocation(::unrealpb::FVector* goallocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goallocation_);
  }
  if (goallocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goallocation));
    if (message_arena != submessage_arena) {
      goallocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goallocation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.goallocation_ = goallocation;
  // @@protoc_insertion_point(field_set_allocated:tpspb.TestNPCState.goalLocation)
}

// -------------------------------------------------------------------

// EntityChannelData

// .unrealpb.UnrealObjectRef objRef = 1;
inline bool EntityChannelData::_internal_has_objref() const {
  return this != internal_default_instance() && _impl_.objref_ != nullptr;
}
inline bool EntityChannelData::has_objref() const {
  return _internal_has_objref();
}
inline const ::unrealpb::UnrealObjectRef& EntityChannelData::_internal_objref() const {
  const ::unrealpb::UnrealObjectRef* p = _impl_.objref_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::UnrealObjectRef&>(
      ::unrealpb::_UnrealObjectRef_default_instance_);
}
inline const ::unrealpb::UnrealObjectRef& EntityChannelData::objref() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.objRef)
  return _internal_objref();
}
inline void EntityChannelData::unsafe_arena_set_allocated_objref(
    ::unrealpb::UnrealObjectRef* objref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objref_);
  }
  _impl_.objref_ = objref;
  if (objref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.objRef)
}
inline ::unrealpb::UnrealObjectRef* EntityChannelData::release_objref() {
  
  ::unrealpb::UnrealObjectRef* temp = _impl_.objref_;
  _impl_.objref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::UnrealObjectRef* EntityChannelData::unsafe_arena_release_objref() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.objRef)
  
  ::unrealpb::UnrealObjectRef* temp = _impl_.objref_;
  _impl_.objref_ = nullptr;
  return temp;
}
inline ::unrealpb::UnrealObjectRef* EntityChannelData::_internal_mutable_objref() {
  
  if (_impl_.objref_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::UnrealObjectRef>(GetArenaForAllocation());
    _impl_.objref_ = p;
  }
  return _impl_.objref_;
}
inline ::unrealpb::UnrealObjectRef* EntityChannelData::mutable_objref() {
  ::unrealpb::UnrealObjectRef* _msg = _internal_mutable_objref();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.objRef)
  return _msg;
}
inline void EntityChannelData::set_allocated_objref(::unrealpb::UnrealObjectRef* objref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objref_);
  }
  if (objref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objref));
    if (message_arena != submessage_arena) {
      objref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objref, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objref_ = objref;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.objRef)
}

// optional .unrealpb.ActorState actorState = 2;
inline bool EntityChannelData::_internal_has_actorstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actorstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_actorstate() const {
  return _internal_has_actorstate();
}
inline const ::unrealpb::ActorState& EntityChannelData::_internal_actorstate() const {
  const ::unrealpb::ActorState* p = _impl_.actorstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::ActorState&>(
      ::unrealpb::_ActorState_default_instance_);
}
inline const ::unrealpb::ActorState& EntityChannelData::actorstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.actorState)
  return _internal_actorstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_actorstate(
    ::unrealpb::ActorState* actorstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actorstate_);
  }
  _impl_.actorstate_ = actorstate;
  if (actorstate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.actorState)
}
inline ::unrealpb::ActorState* EntityChannelData::release_actorstate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::unrealpb::ActorState* temp = _impl_.actorstate_;
  _impl_.actorstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::ActorState* EntityChannelData::unsafe_arena_release_actorstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.actorState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::unrealpb::ActorState* temp = _impl_.actorstate_;
  _impl_.actorstate_ = nullptr;
  return temp;
}
inline ::unrealpb::ActorState* EntityChannelData::_internal_mutable_actorstate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.actorstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::ActorState>(GetArenaForAllocation());
    _impl_.actorstate_ = p;
  }
  return _impl_.actorstate_;
}
inline ::unrealpb::ActorState* EntityChannelData::mutable_actorstate() {
  ::unrealpb::ActorState* _msg = _internal_mutable_actorstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.actorState)
  return _msg;
}
inline void EntityChannelData::set_allocated_actorstate(::unrealpb::ActorState* actorstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actorstate_);
  }
  if (actorstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actorstate));
    if (message_arena != submessage_arena) {
      actorstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actorstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.actorstate_ = actorstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.actorState)
}

// optional .unrealpb.PawnState pawnState = 3;
inline bool EntityChannelData::_internal_has_pawnstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pawnstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_pawnstate() const {
  return _internal_has_pawnstate();
}
inline const ::unrealpb::PawnState& EntityChannelData::_internal_pawnstate() const {
  const ::unrealpb::PawnState* p = _impl_.pawnstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::PawnState&>(
      ::unrealpb::_PawnState_default_instance_);
}
inline const ::unrealpb::PawnState& EntityChannelData::pawnstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.pawnState)
  return _internal_pawnstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_pawnstate(
    ::unrealpb::PawnState* pawnstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pawnstate_);
  }
  _impl_.pawnstate_ = pawnstate;
  if (pawnstate) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.pawnState)
}
inline ::unrealpb::PawnState* EntityChannelData::release_pawnstate() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::unrealpb::PawnState* temp = _impl_.pawnstate_;
  _impl_.pawnstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::PawnState* EntityChannelData::unsafe_arena_release_pawnstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.pawnState)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::unrealpb::PawnState* temp = _impl_.pawnstate_;
  _impl_.pawnstate_ = nullptr;
  return temp;
}
inline ::unrealpb::PawnState* EntityChannelData::_internal_mutable_pawnstate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pawnstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::PawnState>(GetArenaForAllocation());
    _impl_.pawnstate_ = p;
  }
  return _impl_.pawnstate_;
}
inline ::unrealpb::PawnState* EntityChannelData::mutable_pawnstate() {
  ::unrealpb::PawnState* _msg = _internal_mutable_pawnstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.pawnState)
  return _msg;
}
inline void EntityChannelData::set_allocated_pawnstate(::unrealpb::PawnState* pawnstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pawnstate_);
  }
  if (pawnstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pawnstate));
    if (message_arena != submessage_arena) {
      pawnstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pawnstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pawnstate_ = pawnstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.pawnState)
}

// optional .unrealpb.CharacterState characterState = 4;
inline bool EntityChannelData::_internal_has_characterstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.characterstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_characterstate() const {
  return _internal_has_characterstate();
}
inline const ::unrealpb::CharacterState& EntityChannelData::_internal_characterstate() const {
  const ::unrealpb::CharacterState* p = _impl_.characterstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::CharacterState&>(
      ::unrealpb::_CharacterState_default_instance_);
}
inline const ::unrealpb::CharacterState& EntityChannelData::characterstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.characterState)
  return _internal_characterstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_characterstate(
    ::unrealpb::CharacterState* characterstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.characterstate_);
  }
  _impl_.characterstate_ = characterstate;
  if (characterstate) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.characterState)
}
inline ::unrealpb::CharacterState* EntityChannelData::release_characterstate() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::unrealpb::CharacterState* temp = _impl_.characterstate_;
  _impl_.characterstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::CharacterState* EntityChannelData::unsafe_arena_release_characterstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.characterState)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::unrealpb::CharacterState* temp = _impl_.characterstate_;
  _impl_.characterstate_ = nullptr;
  return temp;
}
inline ::unrealpb::CharacterState* EntityChannelData::_internal_mutable_characterstate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.characterstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::CharacterState>(GetArenaForAllocation());
    _impl_.characterstate_ = p;
  }
  return _impl_.characterstate_;
}
inline ::unrealpb::CharacterState* EntityChannelData::mutable_characterstate() {
  ::unrealpb::CharacterState* _msg = _internal_mutable_characterstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.characterState)
  return _msg;
}
inline void EntityChannelData::set_allocated_characterstate(::unrealpb::CharacterState* characterstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.characterstate_);
  }
  if (characterstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterstate));
    if (message_arena != submessage_arena) {
      characterstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.characterstate_ = characterstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.characterState)
}

// optional .unrealpb.PlayerState playerState = 5;
inline bool EntityChannelData::_internal_has_playerstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.playerstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_playerstate() const {
  return _internal_has_playerstate();
}
inline const ::unrealpb::PlayerState& EntityChannelData::_internal_playerstate() const {
  const ::unrealpb::PlayerState* p = _impl_.playerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::PlayerState&>(
      ::unrealpb::_PlayerState_default_instance_);
}
inline const ::unrealpb::PlayerState& EntityChannelData::playerstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.playerState)
  return _internal_playerstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_playerstate(
    ::unrealpb::PlayerState* playerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerstate_);
  }
  _impl_.playerstate_ = playerstate;
  if (playerstate) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.playerState)
}
inline ::unrealpb::PlayerState* EntityChannelData::release_playerstate() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::unrealpb::PlayerState* temp = _impl_.playerstate_;
  _impl_.playerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::PlayerState* EntityChannelData::unsafe_arena_release_playerstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.playerState)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::unrealpb::PlayerState* temp = _impl_.playerstate_;
  _impl_.playerstate_ = nullptr;
  return temp;
}
inline ::unrealpb::PlayerState* EntityChannelData::_internal_mutable_playerstate() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.playerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::PlayerState>(GetArenaForAllocation());
    _impl_.playerstate_ = p;
  }
  return _impl_.playerstate_;
}
inline ::unrealpb::PlayerState* EntityChannelData::mutable_playerstate() {
  ::unrealpb::PlayerState* _msg = _internal_mutable_playerstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.playerState)
  return _msg;
}
inline void EntityChannelData::set_allocated_playerstate(::unrealpb::PlayerState* playerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerstate_);
  }
  if (playerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerstate));
    if (message_arena != submessage_arena) {
      playerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.playerstate_ = playerstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.playerState)
}

// optional .unrealpb.ControllerState controllerState = 6;
inline bool EntityChannelData::_internal_has_controllerstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controllerstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_controllerstate() const {
  return _internal_has_controllerstate();
}
inline const ::unrealpb::ControllerState& EntityChannelData::_internal_controllerstate() const {
  const ::unrealpb::ControllerState* p = _impl_.controllerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::ControllerState&>(
      ::unrealpb::_ControllerState_default_instance_);
}
inline const ::unrealpb::ControllerState& EntityChannelData::controllerstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.controllerState)
  return _internal_controllerstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_controllerstate(
    ::unrealpb::ControllerState* controllerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controllerstate_);
  }
  _impl_.controllerstate_ = controllerstate;
  if (controllerstate) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.controllerState)
}
inline ::unrealpb::ControllerState* EntityChannelData::release_controllerstate() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::unrealpb::ControllerState* temp = _impl_.controllerstate_;
  _impl_.controllerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::ControllerState* EntityChannelData::unsafe_arena_release_controllerstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.controllerState)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::unrealpb::ControllerState* temp = _impl_.controllerstate_;
  _impl_.controllerstate_ = nullptr;
  return temp;
}
inline ::unrealpb::ControllerState* EntityChannelData::_internal_mutable_controllerstate() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.controllerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::ControllerState>(GetArenaForAllocation());
    _impl_.controllerstate_ = p;
  }
  return _impl_.controllerstate_;
}
inline ::unrealpb::ControllerState* EntityChannelData::mutable_controllerstate() {
  ::unrealpb::ControllerState* _msg = _internal_mutable_controllerstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.controllerState)
  return _msg;
}
inline void EntityChannelData::set_allocated_controllerstate(::unrealpb::ControllerState* controllerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controllerstate_);
  }
  if (controllerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controllerstate));
    if (message_arena != submessage_arena) {
      controllerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controllerstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.controllerstate_ = controllerstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.controllerState)
}

// optional .unrealpb.PlayerControllerState playerControllerState = 7;
inline bool EntityChannelData::_internal_has_playercontrollerstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.playercontrollerstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_playercontrollerstate() const {
  return _internal_has_playercontrollerstate();
}
inline const ::unrealpb::PlayerControllerState& EntityChannelData::_internal_playercontrollerstate() const {
  const ::unrealpb::PlayerControllerState* p = _impl_.playercontrollerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::PlayerControllerState&>(
      ::unrealpb::_PlayerControllerState_default_instance_);
}
inline const ::unrealpb::PlayerControllerState& EntityChannelData::playercontrollerstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.playerControllerState)
  return _internal_playercontrollerstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_playercontrollerstate(
    ::unrealpb::PlayerControllerState* playercontrollerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playercontrollerstate_);
  }
  _impl_.playercontrollerstate_ = playercontrollerstate;
  if (playercontrollerstate) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.playerControllerState)
}
inline ::unrealpb::PlayerControllerState* EntityChannelData::release_playercontrollerstate() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::unrealpb::PlayerControllerState* temp = _impl_.playercontrollerstate_;
  _impl_.playercontrollerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::PlayerControllerState* EntityChannelData::unsafe_arena_release_playercontrollerstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.playerControllerState)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::unrealpb::PlayerControllerState* temp = _impl_.playercontrollerstate_;
  _impl_.playercontrollerstate_ = nullptr;
  return temp;
}
inline ::unrealpb::PlayerControllerState* EntityChannelData::_internal_mutable_playercontrollerstate() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.playercontrollerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::PlayerControllerState>(GetArenaForAllocation());
    _impl_.playercontrollerstate_ = p;
  }
  return _impl_.playercontrollerstate_;
}
inline ::unrealpb::PlayerControllerState* EntityChannelData::mutable_playercontrollerstate() {
  ::unrealpb::PlayerControllerState* _msg = _internal_mutable_playercontrollerstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.playerControllerState)
  return _msg;
}
inline void EntityChannelData::set_allocated_playercontrollerstate(::unrealpb::PlayerControllerState* playercontrollerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playercontrollerstate_);
  }
  if (playercontrollerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playercontrollerstate));
    if (message_arena != submessage_arena) {
      playercontrollerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playercontrollerstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.playercontrollerstate_ = playercontrollerstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.playerControllerState)
}

// optional .unrealpb.ActorComponentState actorComponentState = 8;
inline bool EntityChannelData::_internal_has_actorcomponentstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actorcomponentstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_actorcomponentstate() const {
  return _internal_has_actorcomponentstate();
}
inline const ::unrealpb::ActorComponentState& EntityChannelData::_internal_actorcomponentstate() const {
  const ::unrealpb::ActorComponentState* p = _impl_.actorcomponentstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::ActorComponentState&>(
      ::unrealpb::_ActorComponentState_default_instance_);
}
inline const ::unrealpb::ActorComponentState& EntityChannelData::actorcomponentstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.actorComponentState)
  return _internal_actorcomponentstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_actorcomponentstate(
    ::unrealpb::ActorComponentState* actorcomponentstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actorcomponentstate_);
  }
  _impl_.actorcomponentstate_ = actorcomponentstate;
  if (actorcomponentstate) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.actorComponentState)
}
inline ::unrealpb::ActorComponentState* EntityChannelData::release_actorcomponentstate() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::unrealpb::ActorComponentState* temp = _impl_.actorcomponentstate_;
  _impl_.actorcomponentstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::ActorComponentState* EntityChannelData::unsafe_arena_release_actorcomponentstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.actorComponentState)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::unrealpb::ActorComponentState* temp = _impl_.actorcomponentstate_;
  _impl_.actorcomponentstate_ = nullptr;
  return temp;
}
inline ::unrealpb::ActorComponentState* EntityChannelData::_internal_mutable_actorcomponentstate() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.actorcomponentstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::ActorComponentState>(GetArenaForAllocation());
    _impl_.actorcomponentstate_ = p;
  }
  return _impl_.actorcomponentstate_;
}
inline ::unrealpb::ActorComponentState* EntityChannelData::mutable_actorcomponentstate() {
  ::unrealpb::ActorComponentState* _msg = _internal_mutable_actorcomponentstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.actorComponentState)
  return _msg;
}
inline void EntityChannelData::set_allocated_actorcomponentstate(::unrealpb::ActorComponentState* actorcomponentstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actorcomponentstate_);
  }
  if (actorcomponentstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actorcomponentstate));
    if (message_arena != submessage_arena) {
      actorcomponentstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actorcomponentstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.actorcomponentstate_ = actorcomponentstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.actorComponentState)
}

// optional .unrealpb.SceneComponentState sceneComponentState = 9;
inline bool EntityChannelData::_internal_has_scenecomponentstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scenecomponentstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_scenecomponentstate() const {
  return _internal_has_scenecomponentstate();
}
inline const ::unrealpb::SceneComponentState& EntityChannelData::_internal_scenecomponentstate() const {
  const ::unrealpb::SceneComponentState* p = _impl_.scenecomponentstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::SceneComponentState&>(
      ::unrealpb::_SceneComponentState_default_instance_);
}
inline const ::unrealpb::SceneComponentState& EntityChannelData::scenecomponentstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.sceneComponentState)
  return _internal_scenecomponentstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_scenecomponentstate(
    ::unrealpb::SceneComponentState* scenecomponentstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scenecomponentstate_);
  }
  _impl_.scenecomponentstate_ = scenecomponentstate;
  if (scenecomponentstate) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.sceneComponentState)
}
inline ::unrealpb::SceneComponentState* EntityChannelData::release_scenecomponentstate() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::unrealpb::SceneComponentState* temp = _impl_.scenecomponentstate_;
  _impl_.scenecomponentstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::SceneComponentState* EntityChannelData::unsafe_arena_release_scenecomponentstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.sceneComponentState)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::unrealpb::SceneComponentState* temp = _impl_.scenecomponentstate_;
  _impl_.scenecomponentstate_ = nullptr;
  return temp;
}
inline ::unrealpb::SceneComponentState* EntityChannelData::_internal_mutable_scenecomponentstate() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.scenecomponentstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::SceneComponentState>(GetArenaForAllocation());
    _impl_.scenecomponentstate_ = p;
  }
  return _impl_.scenecomponentstate_;
}
inline ::unrealpb::SceneComponentState* EntityChannelData::mutable_scenecomponentstate() {
  ::unrealpb::SceneComponentState* _msg = _internal_mutable_scenecomponentstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.sceneComponentState)
  return _msg;
}
inline void EntityChannelData::set_allocated_scenecomponentstate(::unrealpb::SceneComponentState* scenecomponentstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scenecomponentstate_);
  }
  if (scenecomponentstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenecomponentstate));
    if (message_arena != submessage_arena) {
      scenecomponentstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenecomponentstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.scenecomponentstate_ = scenecomponentstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.sceneComponentState)
}

// optional .tpspb.TestRepPlayerControllerState testRepPlayerControllerState = 11;
inline bool EntityChannelData::_internal_has_testrepplayercontrollerstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.testrepplayercontrollerstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_testrepplayercontrollerstate() const {
  return _internal_has_testrepplayercontrollerstate();
}
inline void EntityChannelData::clear_testrepplayercontrollerstate() {
  if (_impl_.testrepplayercontrollerstate_ != nullptr) _impl_.testrepplayercontrollerstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::tpspb::TestRepPlayerControllerState& EntityChannelData::_internal_testrepplayercontrollerstate() const {
  const ::tpspb::TestRepPlayerControllerState* p = _impl_.testrepplayercontrollerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::tpspb::TestRepPlayerControllerState&>(
      ::tpspb::_TestRepPlayerControllerState_default_instance_);
}
inline const ::tpspb::TestRepPlayerControllerState& EntityChannelData::testrepplayercontrollerstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.testRepPlayerControllerState)
  return _internal_testrepplayercontrollerstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_testrepplayercontrollerstate(
    ::tpspb::TestRepPlayerControllerState* testrepplayercontrollerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testrepplayercontrollerstate_);
  }
  _impl_.testrepplayercontrollerstate_ = testrepplayercontrollerstate;
  if (testrepplayercontrollerstate) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.testRepPlayerControllerState)
}
inline ::tpspb::TestRepPlayerControllerState* EntityChannelData::release_testrepplayercontrollerstate() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::tpspb::TestRepPlayerControllerState* temp = _impl_.testrepplayercontrollerstate_;
  _impl_.testrepplayercontrollerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tpspb::TestRepPlayerControllerState* EntityChannelData::unsafe_arena_release_testrepplayercontrollerstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.testRepPlayerControllerState)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::tpspb::TestRepPlayerControllerState* temp = _impl_.testrepplayercontrollerstate_;
  _impl_.testrepplayercontrollerstate_ = nullptr;
  return temp;
}
inline ::tpspb::TestRepPlayerControllerState* EntityChannelData::_internal_mutable_testrepplayercontrollerstate() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.testrepplayercontrollerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::tpspb::TestRepPlayerControllerState>(GetArenaForAllocation());
    _impl_.testrepplayercontrollerstate_ = p;
  }
  return _impl_.testrepplayercontrollerstate_;
}
inline ::tpspb::TestRepPlayerControllerState* EntityChannelData::mutable_testrepplayercontrollerstate() {
  ::tpspb::TestRepPlayerControllerState* _msg = _internal_mutable_testrepplayercontrollerstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.testRepPlayerControllerState)
  return _msg;
}
inline void EntityChannelData::set_allocated_testrepplayercontrollerstate(::tpspb::TestRepPlayerControllerState* testrepplayercontrollerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testrepplayercontrollerstate_;
  }
  if (testrepplayercontrollerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testrepplayercontrollerstate);
    if (message_arena != submessage_arena) {
      testrepplayercontrollerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testrepplayercontrollerstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.testrepplayercontrollerstate_ = testrepplayercontrollerstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.testRepPlayerControllerState)
}

// optional .tpspb.TestNPCState testNPCState = 12;
inline bool EntityChannelData::_internal_has_testnpcstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.testnpcstate_ != nullptr);
  return value;
}
inline bool EntityChannelData::has_testnpcstate() const {
  return _internal_has_testnpcstate();
}
inline void EntityChannelData::clear_testnpcstate() {
  if (_impl_.testnpcstate_ != nullptr) _impl_.testnpcstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::tpspb::TestNPCState& EntityChannelData::_internal_testnpcstate() const {
  const ::tpspb::TestNPCState* p = _impl_.testnpcstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::tpspb::TestNPCState&>(
      ::tpspb::_TestNPCState_default_instance_);
}
inline const ::tpspb::TestNPCState& EntityChannelData::testnpcstate() const {
  // @@protoc_insertion_point(field_get:tpspb.EntityChannelData.testNPCState)
  return _internal_testnpcstate();
}
inline void EntityChannelData::unsafe_arena_set_allocated_testnpcstate(
    ::tpspb::TestNPCState* testnpcstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testnpcstate_);
  }
  _impl_.testnpcstate_ = testnpcstate;
  if (testnpcstate) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.EntityChannelData.testNPCState)
}
inline ::tpspb::TestNPCState* EntityChannelData::release_testnpcstate() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::tpspb::TestNPCState* temp = _impl_.testnpcstate_;
  _impl_.testnpcstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tpspb::TestNPCState* EntityChannelData::unsafe_arena_release_testnpcstate() {
  // @@protoc_insertion_point(field_release:tpspb.EntityChannelData.testNPCState)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::tpspb::TestNPCState* temp = _impl_.testnpcstate_;
  _impl_.testnpcstate_ = nullptr;
  return temp;
}
inline ::tpspb::TestNPCState* EntityChannelData::_internal_mutable_testnpcstate() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.testnpcstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::tpspb::TestNPCState>(GetArenaForAllocation());
    _impl_.testnpcstate_ = p;
  }
  return _impl_.testnpcstate_;
}
inline ::tpspb::TestNPCState* EntityChannelData::mutable_testnpcstate() {
  ::tpspb::TestNPCState* _msg = _internal_mutable_testnpcstate();
  // @@protoc_insertion_point(field_mutable:tpspb.EntityChannelData.testNPCState)
  return _msg;
}
inline void EntityChannelData::set_allocated_testnpcstate(::tpspb::TestNPCState* testnpcstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testnpcstate_;
  }
  if (testnpcstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testnpcstate);
    if (message_arena != submessage_arena) {
      testnpcstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testnpcstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.testnpcstate_ = testnpcstate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.EntityChannelData.testNPCState)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestRepChannelData

// .unrealpb.GameStateBase gameState = 1;
inline bool TestRepChannelData::_internal_has_gamestate() const {
  return this != internal_default_instance() && _impl_.gamestate_ != nullptr;
}
inline bool TestRepChannelData::has_gamestate() const {
  return _internal_has_gamestate();
}
inline const ::unrealpb::GameStateBase& TestRepChannelData::_internal_gamestate() const {
  const ::unrealpb::GameStateBase* p = _impl_.gamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::unrealpb::GameStateBase&>(
      ::unrealpb::_GameStateBase_default_instance_);
}
inline const ::unrealpb::GameStateBase& TestRepChannelData::gamestate() const {
  // @@protoc_insertion_point(field_get:tpspb.TestRepChannelData.gameState)
  return _internal_gamestate();
}
inline void TestRepChannelData::unsafe_arena_set_allocated_gamestate(
    ::unrealpb::GameStateBase* gamestate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gamestate_);
  }
  _impl_.gamestate_ = gamestate;
  if (gamestate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.TestRepChannelData.gameState)
}
inline ::unrealpb::GameStateBase* TestRepChannelData::release_gamestate() {
  
  ::unrealpb::GameStateBase* temp = _impl_.gamestate_;
  _impl_.gamestate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unrealpb::GameStateBase* TestRepChannelData::unsafe_arena_release_gamestate() {
  // @@protoc_insertion_point(field_release:tpspb.TestRepChannelData.gameState)
  
  ::unrealpb::GameStateBase* temp = _impl_.gamestate_;
  _impl_.gamestate_ = nullptr;
  return temp;
}
inline ::unrealpb::GameStateBase* TestRepChannelData::_internal_mutable_gamestate() {
  
  if (_impl_.gamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::unrealpb::GameStateBase>(GetArenaForAllocation());
    _impl_.gamestate_ = p;
  }
  return _impl_.gamestate_;
}
inline ::unrealpb::GameStateBase* TestRepChannelData::mutable_gamestate() {
  ::unrealpb::GameStateBase* _msg = _internal_mutable_gamestate();
  // @@protoc_insertion_point(field_mutable:tpspb.TestRepChannelData.gameState)
  return _msg;
}
inline void TestRepChannelData::set_allocated_gamestate(::unrealpb::GameStateBase* gamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gamestate_);
  }
  if (gamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamestate));
    if (message_arena != submessage_arena) {
      gamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamestate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gamestate_ = gamestate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.TestRepChannelData.gameState)
}

// map<uint32, .unrealpb.ActorState> actorStates = 2;
inline int TestRepChannelData::_internal_actorstates_size() const {
  return _impl_.actorstates_.size();
}
inline int TestRepChannelData::actorstates_size() const {
  return _internal_actorstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >&
TestRepChannelData::_internal_actorstates() const {
  return _impl_.actorstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >&
TestRepChannelData::actorstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.actorStates)
  return _internal_actorstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >*
TestRepChannelData::_internal_mutable_actorstates() {
  return _impl_.actorstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorState >*
TestRepChannelData::mutable_actorstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.actorStates)
  return _internal_mutable_actorstates();
}

// map<uint32, .unrealpb.PawnState> pawnStates = 3;
inline int TestRepChannelData::_internal_pawnstates_size() const {
  return _impl_.pawnstates_.size();
}
inline int TestRepChannelData::pawnstates_size() const {
  return _internal_pawnstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >&
TestRepChannelData::_internal_pawnstates() const {
  return _impl_.pawnstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >&
TestRepChannelData::pawnstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.pawnStates)
  return _internal_pawnstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >*
TestRepChannelData::_internal_mutable_pawnstates() {
  return _impl_.pawnstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PawnState >*
TestRepChannelData::mutable_pawnstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.pawnStates)
  return _internal_mutable_pawnstates();
}

// map<uint32, .unrealpb.CharacterState> characterStates = 4;
inline int TestRepChannelData::_internal_characterstates_size() const {
  return _impl_.characterstates_.size();
}
inline int TestRepChannelData::characterstates_size() const {
  return _internal_characterstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >&
TestRepChannelData::_internal_characterstates() const {
  return _impl_.characterstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >&
TestRepChannelData::characterstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.characterStates)
  return _internal_characterstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >*
TestRepChannelData::_internal_mutable_characterstates() {
  return _impl_.characterstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::CharacterState >*
TestRepChannelData::mutable_characterstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.characterStates)
  return _internal_mutable_characterstates();
}

// map<uint32, .unrealpb.PlayerState> playerStates = 5;
inline int TestRepChannelData::_internal_playerstates_size() const {
  return _impl_.playerstates_.size();
}
inline int TestRepChannelData::playerstates_size() const {
  return _internal_playerstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >&
TestRepChannelData::_internal_playerstates() const {
  return _impl_.playerstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >&
TestRepChannelData::playerstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.playerStates)
  return _internal_playerstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >*
TestRepChannelData::_internal_mutable_playerstates() {
  return _impl_.playerstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerState >*
TestRepChannelData::mutable_playerstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.playerStates)
  return _internal_mutable_playerstates();
}

// map<uint32, .unrealpb.ControllerState> controllerStates = 6;
inline int TestRepChannelData::_internal_controllerstates_size() const {
  return _impl_.controllerstates_.size();
}
inline int TestRepChannelData::controllerstates_size() const {
  return _internal_controllerstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >&
TestRepChannelData::_internal_controllerstates() const {
  return _impl_.controllerstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >&
TestRepChannelData::controllerstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.controllerStates)
  return _internal_controllerstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >*
TestRepChannelData::_internal_mutable_controllerstates() {
  return _impl_.controllerstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ControllerState >*
TestRepChannelData::mutable_controllerstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.controllerStates)
  return _internal_mutable_controllerstates();
}

// map<uint32, .unrealpb.PlayerControllerState> playerControllerStates = 7;
inline int TestRepChannelData::_internal_playercontrollerstates_size() const {
  return _impl_.playercontrollerstates_.size();
}
inline int TestRepChannelData::playercontrollerstates_size() const {
  return _internal_playercontrollerstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >&
TestRepChannelData::_internal_playercontrollerstates() const {
  return _impl_.playercontrollerstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >&
TestRepChannelData::playercontrollerstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.playerControllerStates)
  return _internal_playercontrollerstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >*
TestRepChannelData::_internal_mutable_playercontrollerstates() {
  return _impl_.playercontrollerstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::PlayerControllerState >*
TestRepChannelData::mutable_playercontrollerstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.playerControllerStates)
  return _internal_mutable_playercontrollerstates();
}

// map<uint32, .unrealpb.ActorComponentState> actorComponentStates = 8;
inline int TestRepChannelData::_internal_actorcomponentstates_size() const {
  return _impl_.actorcomponentstates_.size();
}
inline int TestRepChannelData::actorcomponentstates_size() const {
  return _internal_actorcomponentstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >&
TestRepChannelData::_internal_actorcomponentstates() const {
  return _impl_.actorcomponentstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >&
TestRepChannelData::actorcomponentstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.actorComponentStates)
  return _internal_actorcomponentstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >*
TestRepChannelData::_internal_mutable_actorcomponentstates() {
  return _impl_.actorcomponentstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::ActorComponentState >*
TestRepChannelData::mutable_actorcomponentstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.actorComponentStates)
  return _internal_mutable_actorcomponentstates();
}

// map<uint32, .unrealpb.SceneComponentState> sceneComponentStates = 9;
inline int TestRepChannelData::_internal_scenecomponentstates_size() const {
  return _impl_.scenecomponentstates_.size();
}
inline int TestRepChannelData::scenecomponentstates_size() const {
  return _internal_scenecomponentstates_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >&
TestRepChannelData::_internal_scenecomponentstates() const {
  return _impl_.scenecomponentstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >&
TestRepChannelData::scenecomponentstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.sceneComponentStates)
  return _internal_scenecomponentstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >*
TestRepChannelData::_internal_mutable_scenecomponentstates() {
  return _impl_.scenecomponentstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SceneComponentState >*
TestRepChannelData::mutable_scenecomponentstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.sceneComponentStates)
  return _internal_mutable_scenecomponentstates();
}

// .tpspb.TestRepGameState testGameState = 10;
inline bool TestRepChannelData::_internal_has_testgamestate() const {
  return this != internal_default_instance() && _impl_.testgamestate_ != nullptr;
}
inline bool TestRepChannelData::has_testgamestate() const {
  return _internal_has_testgamestate();
}
inline void TestRepChannelData::clear_testgamestate() {
  if (GetArenaForAllocation() == nullptr && _impl_.testgamestate_ != nullptr) {
    delete _impl_.testgamestate_;
  }
  _impl_.testgamestate_ = nullptr;
}
inline const ::tpspb::TestRepGameState& TestRepChannelData::_internal_testgamestate() const {
  const ::tpspb::TestRepGameState* p = _impl_.testgamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::tpspb::TestRepGameState&>(
      ::tpspb::_TestRepGameState_default_instance_);
}
inline const ::tpspb::TestRepGameState& TestRepChannelData::testgamestate() const {
  // @@protoc_insertion_point(field_get:tpspb.TestRepChannelData.testGameState)
  return _internal_testgamestate();
}
inline void TestRepChannelData::unsafe_arena_set_allocated_testgamestate(
    ::tpspb::TestRepGameState* testgamestate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testgamestate_);
  }
  _impl_.testgamestate_ = testgamestate;
  if (testgamestate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpspb.TestRepChannelData.testGameState)
}
inline ::tpspb::TestRepGameState* TestRepChannelData::release_testgamestate() {
  
  ::tpspb::TestRepGameState* temp = _impl_.testgamestate_;
  _impl_.testgamestate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tpspb::TestRepGameState* TestRepChannelData::unsafe_arena_release_testgamestate() {
  // @@protoc_insertion_point(field_release:tpspb.TestRepChannelData.testGameState)
  
  ::tpspb::TestRepGameState* temp = _impl_.testgamestate_;
  _impl_.testgamestate_ = nullptr;
  return temp;
}
inline ::tpspb::TestRepGameState* TestRepChannelData::_internal_mutable_testgamestate() {
  
  if (_impl_.testgamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::tpspb::TestRepGameState>(GetArenaForAllocation());
    _impl_.testgamestate_ = p;
  }
  return _impl_.testgamestate_;
}
inline ::tpspb::TestRepGameState* TestRepChannelData::mutable_testgamestate() {
  ::tpspb::TestRepGameState* _msg = _internal_mutable_testgamestate();
  // @@protoc_insertion_point(field_mutable:tpspb.TestRepChannelData.testGameState)
  return _msg;
}
inline void TestRepChannelData::set_allocated_testgamestate(::tpspb::TestRepGameState* testgamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testgamestate_;
  }
  if (testgamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testgamestate);
    if (message_arena != submessage_arena) {
      testgamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testgamestate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.testgamestate_ = testgamestate;
  // @@protoc_insertion_point(field_set_allocated:tpspb.TestRepChannelData.testGameState)
}

// map<uint32, .tpspb.TestRepPlayerControllerState> testRepPlayerControllerStates = 11;
inline int TestRepChannelData::_internal_testrepplayercontrollerstates_size() const {
  return _impl_.testrepplayercontrollerstates_.size();
}
inline int TestRepChannelData::testrepplayercontrollerstates_size() const {
  return _internal_testrepplayercontrollerstates_size();
}
inline void TestRepChannelData::clear_testrepplayercontrollerstates() {
  _impl_.testrepplayercontrollerstates_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >&
TestRepChannelData::_internal_testrepplayercontrollerstates() const {
  return _impl_.testrepplayercontrollerstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >&
TestRepChannelData::testrepplayercontrollerstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.testRepPlayerControllerStates)
  return _internal_testrepplayercontrollerstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >*
TestRepChannelData::_internal_mutable_testrepplayercontrollerstates() {
  return _impl_.testrepplayercontrollerstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestRepPlayerControllerState >*
TestRepChannelData::mutable_testrepplayercontrollerstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.testRepPlayerControllerStates)
  return _internal_mutable_testrepplayercontrollerstates();
}

// map<uint32, .tpspb.TestNPCState> testNPCStates = 12;
inline int TestRepChannelData::_internal_testnpcstates_size() const {
  return _impl_.testnpcstates_.size();
}
inline int TestRepChannelData::testnpcstates_size() const {
  return _internal_testnpcstates_size();
}
inline void TestRepChannelData::clear_testnpcstates() {
  _impl_.testnpcstates_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >&
TestRepChannelData::_internal_testnpcstates() const {
  return _impl_.testnpcstates_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >&
TestRepChannelData::testnpcstates() const {
  // @@protoc_insertion_point(field_map:tpspb.TestRepChannelData.testNPCStates)
  return _internal_testnpcstates();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >*
TestRepChannelData::_internal_mutable_testnpcstates() {
  return _impl_.testnpcstates_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::tpspb::TestNPCState >*
TestRepChannelData::mutable_testnpcstates() {
  // @@protoc_insertion_point(field_mutable_map:tpspb.TestRepChannelData.testNPCStates)
  return _internal_mutable_testnpcstates();
}

// -------------------------------------------------------------------

// TestRepGameState_MulticastNumber_Params

// optional int32 num = 1;
inline bool TestRepGameState_MulticastNumber_Params::_internal_has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestRepGameState_MulticastNumber_Params::has_num() const {
  return _internal_has_num();
}
inline void TestRepGameState_MulticastNumber_Params::clear_num() {
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestRepGameState_MulticastNumber_Params::_internal_num() const {
  return _impl_.num_;
}
inline int32_t TestRepGameState_MulticastNumber_Params::num() const {
  // @@protoc_insertion_point(field_get:tpspb.TestRepGameState_MulticastNumber_Params.num)
  return _internal_num();
}
inline void TestRepGameState_MulticastNumber_Params::_internal_set_num(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_ = value;
}
inline void TestRepGameState_MulticastNumber_Params::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:tpspb.TestRepGameState_MulticastNumber_Params.num)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tpspb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tps_2eproto
